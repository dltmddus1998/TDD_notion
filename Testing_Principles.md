## ✍️ 테스트의 비밀

---

1. **한번 작성된 테스트 코드는 영원히 유지보수**해야 한다.
2. **내부 구현 사항을 테스트하면 안된다.**
    1. 사용자 입장에서 API만으로 테스트해야 한다.
    2. 내부에서 변수명을 변경하거나 구현사항을 조금만 변경해도 테스트 코드가 실패할 수 있다.
3. **재사용성을 높인다.** (테스트 유틸리티)
4. **배포용 코드와 철저히 분리**한다.
5. **테스트 코드를 통한 문서화**

<br>

## ⚙️ 테스트 코드의 구조

---

1. **Before**
2. **Test** (Triple-A || GWT)
    1. **Arrange(준비) || Given**
        1. 준비 과정이 반복된다면 이를 **재사용할 수 있도록 따로 유틸리티 함수로 정의**해서 사용하자.
    2. **Act(실행) || When**
        1. 코드 실행시 **의도적으로 실패**해보자 → 실패하지 않도록 하기 위해 코드 수정을 어떻게 해야하는지 확인해보자.
        2. 버그를 수정할 때 실패하는 테스트를 먼저 만들어서, 버그가 어떤 상황에 발생하는지 검증한 후 버그를 수정해서 테스트 코드가 성공하도록 만드는 게 중요하다.
    3. **Assert(검증) || Then**
        1. **가장 마지막에 두자.**
    
    ```tsx
    it('should filter out only available items', async () => {
    	// Arrange, Given
    	const productService = new ProductService(new StubProductClient());
    	
    	// Act, When
    	const items = await productService.fetchAvailableItems();
    	
    	// Assert, Then
    	expect(items.length).toBe(1);
    	expect(items).toEqual([{ item: '🥛', available: true }]);
    })
    ```
    
3. **After**

<br>

## 👑 좋은 테스트의 원칙

---

### 👀 **F** **I** **R** **S** **T** 원칙

- **Fast - 느린 것에 대한 의존성 낮추기**
    - 파일, 데이터베이스, 네트워크에 대한 의존성 낮추기
    → **Mock, Stub 사용**
- **Isolated - 최소한의 유닛으로 검증하기**
    - 독립적이고, 집중적으로 유지
    → 하나의 테스트에서 너무 많은 것을 테스트해서 어떤 부분이 잘못됐는지 모르게 작성하는 게 아니라, 독립적이고 날카롭게 테스트 코드를 작성해서 어디가 잘못됐는지 한번에 알 수 있게 해야 한다.
- **Repeatable - 실행할 때마다 동일한 결과 유지**
    - 언제 실행하냐에 따라 다른 결과를 제공한다면 테스트 코드가 잘못된 것이다.
    → 따라서, **테스트 코드는 환경에 영향을 받지 않도록 작성해야 한다**.
        - 다른 테스트 코드에 의존하는 경우
        - 네트워크 등과 같은 불안정한 외부적 환경에 의존하는 경우
- **Self-Validating - 스스로 결과를 검증하기**
    - **자동화를 통한 검증 단계 (CI/CD)**
        - 새로운 코드 추가시 모든 테스트가 실행되어서 기존의 코드에 영향을 주지 않는지 검증할 수 있다.
- **Timely - 시기적절하게 테스트 코드 작성**
    - **사용자에게 배포되기 전에 테스트 코드 작성**

<br>

## 🧪 테스트의 범위

---

### **Right-BICEP**

- **Right - 모든 요구사항이 정상 동작하는지 확인**
    - 모든 결과가 정확한지 확인
- **Boundary conditions - 모든 코너 케이스에 대해 테스트하기**
    - 잘못된 포맷의 input, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음 ... 등과 같이 모든 케이스에 대해 테스트가 이뤄져야 한다.
- **Inverse relationship - 역관계를 적용해서 결과값 확인**
    - 일관성 유지 (덧셈 → 뺄셈, 추가 → 제거)
- **Cross-check - 다른 수단을 이용해서 결과값이 맞는지 확인**
    - `추가된 과일 == 전체 과일 - 예전의 과일 개수`
    - `A 알고리즘 == B 알고리즘`
- **Error conditions - 불행한 경로에 대해 우아하게 처리 하는가?**
    - 네트워크 에러, 메모리 부족, 데이터베이스 중지 ...
- **Performance characteristics - 성능 확인은 테스트를 통해 정확한 수치로 확인**
    - 성능 개선의 척도와 확인도 데이터를 통해 확인

<br>

## 🌱 좋은 테스트의 커버리지

---

### CORRECT

- **Conformance - 특정 포맷을 준수**
    - 전화번호, 이메일, 아이디, 파일 확장자...
- **Ordering - 순서 조건 확인하기**
    - 순서가 중요한 경우
- **Range - 숫자의 범위**
    - 제한된 범위보다 작거나 큰 경우
- **Reference - 외부 의존성 유무, 특정한 조건의 유무**
    - **~일 때, ~가 되어 있을 때, 어떤 특정한 상황/상태일 때** 이런 동작을 한다.
- **Existence - 값이 존재하지 않을 때, 어떻게 동작?**
    - null, undefined, “”, 0
- **Cardinality - 0-1-N 법칙에 따라 검증**
    - 하나도 없을 때, 하나만 있을 때, 여러개가 있을 때
- **Time - 상대, 절대, 동시의 일들**
    - 순서가 맞지 않은 경우, 소비한 시간, 지역 시간