## Testing 이란?

---

### **Software Test**

> **제품이나 서비스의 품질을 확인함
소프트웨어의 버그를 찾음
→ 제품이 예상하는 대로 동작하는지 확인 및 검증
+) 제품: 함수, 특정한 기능, UI, 성능, API 스펙**
> 

<aside>
💡 **우리가 정확하게 무엇을 원하는지 (목표), 어떤 플랫폼에서 동작하는 소프트웨어인지, 어떤 환경에서 동작하는지에 따라 다양한 테스트가 존재한다.**

</aside>

<aside>
💡 **테스트는 딱 한 가지의 프로세스로 동작한다.**

</aside>

### 테스팅 프로세스

`특정한 기능 수행하는 코드` → `expectation (requirements)` → `코드가 정확하게 동작하는지 확인하는 테스트 코드` 

- 테스트 코드가 우리가 예상하는 요구사항에 맞게 제품이 동작할 수 있는지 확인하는 것
- 이렇게 작성한 테스트를 주기적으로 실행해서 성공/실패 여부에 따라 실패시 성공할 수 있도록 코드를 수정한다.

## 언제 Software Test를 사용할까?

---

> **과거에는 수동적으로 하나하나 검증하다보니 시간 및 비용의 낭비가 있었다. 
가장 중요한 문제는 개발팀에서 아무리 빠르게 개발해도 검증팀에서 시간이 소요되다보니 여기서 병목현상이 발생한다. 
이를 개선하기 위해 검증팀에서 소프트웨어를 확인할 수 있는 script와 test code를 이용해서, 개발팀이 완성하면 원하는 기능을 자동으로 테스트할 수 있도록 검증 기능을 자동화해왔다.
그래도 개발 완료 시점에서 검증팀에서 별도로 high level의 소프트웨어 기능을 테스트하는 것만으로는 부족하고 병목현상도 여전히 존재하며, 개발이 완료가 된 후에야 QA가 진행되므로 문제가 뒤늦게 발생하는 문제점도 있다.
요즘에는 개발하면서 자동으로 테스트가 되도록 개발하면서 테스트를 작성하는 방식으로 많이 변화해서 프로세스가 개선됐다.**
> 

### 테스트 장점

- 빠른 속도 (자동화)
- 쉽게 작성
- 해당하는 기능에 대한 테스트 작성 → 높은 커버리지
    - 기능 하나 하나를 꼼꼼하게 작성하므로 예전보다 상대적으로 많은 양의 코드를 커버할 수 있음.

<aside>
💡 **개발하면서 수시로 실행할 수 있는 테스트 뿐만 아니라 사용자 입장에서 제품이 어떻게 동작하는지 여전히 다양한 QA를 진행할 수 있다.**

</aside>

## 왜 테스트를 할까?

---

> **우리의 제품이 예상하는대로 동작할 것이라는 큰 자신감을 얻을 수 있다.**
> 

### 테스트 특징 및 장점

- 기능 정상 동작
- 요구 사항 만족
- 이슈에 대해 예측
- 빠른 버그 발견
- **자신감 있게 리팩토링**
- **유지 보수 용이**
- 코드의 품질 향상
- 코드간 의존성 낮춤 → 독립적이고 재사용이 가능한 코드 작성
    - 모듈 간, 클래스 간 의존성을 낮춰야 좋은 테스트 코드 작성 가능
- ⭐️ **좋은 문서화** → 이 모듈은 이렇게 사용하는구나, 이런 상황에서는 이런식으로 하면 되는구나...
- 시간 절약

## 💡 Test Pyramid

---

### 개발자들이 꼭 알아야 하는 Test Pyramid

> 어떤 sw 제품이든 테스트를 작성할 때는 아래 테스트 피라미드를 가지고 가면 좋다.
> 

![Test Pyramid](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8f1ad776-5fc9-4a04-bd73-4ae02bc09135/Untitled.png)

Test Pyramid

1. Unit Test
    1. 단위 테스트 
        1. **독립적인 하나의 컴포넌트 (함수, 모듈, 클래스) 테스트**
        2. 바퀴 하나
2. Integration Test
    1. 통합 테스트
        1. **하나의 단위가 아닌 여러가지 단위를 함께 묶었을 때 이들이 상호작용을 잘 하는지 테스트**
        2. 바퀴 네 개를 연결해서 엔진이 올라갔을 때 바퀴가 돌아가는지
3. E2E Test
    1. end-to-end
    2. UI 테스트 (사용자 테스트)
        1. **사용자가 실제로 우리의 SW를 사용했을 때 flow을 테스트하는 것**
        2. 운전자가 운전했을 때 발생할 수 있는 케이스에 대해 자동차 전체를 테스트

### 특징 (장,단점)

1. Cost : 위로 올라갈 수록 비용이 비싸진다.
    1. **Unit Test는 작성하기도 쉽고 실행하거나 자동화시키는 비용이 저렴한 반면 위로 올라갈수록 작성하기도 까다롭고 비용이 비싸진다.**
    2. **개발적인 효율성 측면 : Unit Test가 훨씬 저렴하다.**
        1. Unit Test의 경우 버그나 오류에 대해 즉각적인 해결이 가능하다. → 비용이 저렴하다.
        2. 모듈이나 클래스 완성된 후 통합적인 부분이나 최종적인 부분을 테스트한다면 어디서 문제가 있는지 추적하는데 더 오랜 시간이 걸리므로 비용이 비싸진다.
2. Speed : Unit Test가 빠르다.
    1. **상대적으로 가볍고 간단한 Unit Test는 실행 속도가 빠른 반면, 브라우저를 실행하거나 다른 플랫폼을 구동하는 E2E Test는 테스트를 실행하는 속도도 더 느리다.**

<aside>
💡 **비용과 속도적인 측면 때문에 Unit Test를 가장 많이 작성해서 프로젝트에서 각각의 단위들이 잘 작동하는지 확실히 테스트 코드를 작성하고, 이들의 통합적인 상호작용을 확인하기 위해 Integration Test, 이후 최종적으로 E2E Test를 진행하는 방식의 Test Pyramid가 구성되어 있다.**

</aside>

<aside>
💡 **Test Pyramid는 기본적인 테스트 모델이고, 이외에도 목표와 어떤 것을 테스트하느냐에 따라 다양한 테스트들이 존재한다.
ex) Contract Test, A/B Test, Stress Test**

</aside>

<aside>
💡 **개발자들은 Unit Test, Integration Test에 대해서만 작성하고, E2E Test의 경우 QA팀에서 수행하는 경우가 많다. (통상적인 경우)
또는 개발자가 모두 작성하는 경우도 있어, 회사에서 어떤 전략을 가지고 가냐에 따라 달라질 수 있다.**

</aside>

## TDD란?

---

### TDD

> **Test-driven development (테스트 주도 개발)
→ 개발전 테스트 코드를 먼저 작성하는 방식**
> 

요구 사항 분석 및 이해 → 설계 → `테스트 코드 작성` → `테스트 실행` → `실패` → `해당 테스트가 통과할 수 있을 정도의 심플한 코드 작성` → `테스트 실행` → `성공`

<aside>
💡 **테스트 먼저 작성하고 코드를 작성해서 전체적인 기능을 구현한다면 그때서야 이미 작성한 코드를 여기저기 수정하고 깨끗하게 만드는 리팩토링을 할 수 있다.**

</aside>

<aside>
💡 **우리가 무얼 원하는지 어떤걸 테스트해야 하는지 요구사항 분석에 대한 철저한 이해를 거친 후 어떤 식으로 코드를 설계해 나갈건지 테스트 코드를 작성할 수 있다. 
TDD의 큰 장점이 여기서 나온다.**

</aside>

### TDD 장점

- 모든 요구 사항에 대해 점검
- 사용자 입장에서 코드 작성
    - 내부 구현 사항보다는 인터페이스 위주로 코드를 작성하므로 의존성이 낮은 코드를 작성하게 되므로, 코드의 퀄리티가 향상된다.
- 시스템 전반적인 설계 향상
- 개발 집중력 향상
    - 실패한 테스트를 성공하도록 만들고 테스트를 짜고 성공하는 과정을 거치면서 개발의 집중력이 향상될 수 있다.

<aside>
💡 여기서 포인트는, 본인이 TDD를 사용하는지 여부를 떠나서, **코드를 레포지토리에 머지하기 전에 꼭 해당 코드에 관한 테스트 코드를 포함해서 머지해야 한다.**

</aside>

### TDD는 언제 사용할까?

- 요구사항이 명확할 때
- 비지니스 로직일 경우
- 협업시 명세서(문서)역할이 필요할 때
- 설계에 대한 고민이 필요할 때

## CI/CD에서의 테스트

---

### CI/CD란?

> **Continuous Integration/Continuous Delivery(Deployment)
어플리케이션 개발 단계부터 배포까지 이 모든 단계를 자동화를 통해 좀 더 효율적이고 빠르게 사용자에게 빈번하게 배포할 수 있도록 만드는 것을 말한다.**
> 

✔︎ **Continuous Integration (지속적인 통합)**

✍️ 버그 수정이나 새로 만드는 기능들이 메인 레포에 주기적으로 빌드되고 테스트되어서 머지되는 것을 말한다.

1. **코드 변경사항**을 **주기적으로 빈번하게** 머지해야 한다.
    1. 코드 변경사항 → 테스트 코드를 포함
2. 통합을 위해 단계(빌드, 테스트, 머지)의 자동화

**CI원칙을 따라갔을 때 장점**

- **개발 생산성 향상**
    - 주기적으로 머지하므로 머지 충돌 피함
- **문제점 빠르게 발견**
    - 머지되는 모든 코드들은 자동으로 빌드되고 테스트됨
- **버그 수정 용이**
    - 주기적으로 머지하기 위해 코드의 변경사항이 잦기 때문에 문제 수정시에도 작은 단위로 수정이 가능함
- **코드의 퀄리티 향상**
    - CI를 잘 운영하려면 모든 개발자들이 자신이 작성하는 코드에 한해서는 Unit Test가 필수적이므로.

<aside>
💡 **CI를 사용하면 프로젝트의 대부분의 소스코드들이 자동으로 테스트되기 때문에 더 안정성있는 제품을 개발할 수 있다.**

</aside>

✔︎ **Continuous Delivery (지속적인 제공)**

✍️ CI 단계에서 주기적으로 빌드되고 테스트된 후, 이제 배포하는 단계에서 배포할 준비과정을 거치고, 준비된 배포가 문제 없는지 검증 후 최종적으로 사용자에게 배포해도 된다고 결정되면 수동적으로 배포하는 단계
✏️ 배포가 준비되자마자 사용자에게 자동으로 배포할 수 있도록 할 수도 있는데 이를 **Continuous Deployment**라 한다.

즉, 배포가 자동화된 여부에 따라 Delivery/Deployment로 갈린다.

**CI/CD 과정**

1. 개발자가 주기적으로 코드를 레포지토리에 머지
2. 자동으로 빌드
3. 테스트
4. 배포 준비
5. 최종 배포 (수동 or 자동)

<aside>
💡 **모든 코드에 대한 테스트 코드가 있다는 것을 가정했을 때 CI/CD의 효과가 발생한다.**

</aside>